{"version":3,"file":"eta.es.js","sources":["../src/err.ts","../src/polyfills.ts","../src/utils.ts","../src/parse.ts","../src/compile-string.ts","../src/storage.ts","../src/containers.ts","../src/config.ts","../src/compile.ts","../src/file-utils.ts","../src/file-handlers.ts","../src/file-helpers.ts","../src/render.ts","../src/index.ts"],"sourcesContent":["function setPrototypeOf(obj: any, proto: any) {\r\n  // eslint-disable-line @typescript-eslint/no-explicit-any\r\n  if (Object.setPrototypeOf) {\r\n    Object.setPrototypeOf(obj, proto)\r\n  } else {\r\n    obj.__proto__ = proto\r\n  }\r\n}\r\n\r\n// This is pretty much the only way to get nice, extended Errors\r\n// without using ES6\r\n\r\n/**\r\n * This returns a new Error with a custom prototype. Note that it's _not_ a constructor\r\n *\r\n * @param message Error message\r\n *\r\n * **Example**\r\n *\r\n * ```js\r\n * throw EtaErr(\"template not found\")\r\n * ```\r\n */\r\n\r\nexport default function EtaErr(message: string): Error {\r\n  const err = new Error(message)\r\n  setPrototypeOf(err, EtaErr.prototype)\r\n  return err\r\n}\r\n\r\nEtaErr.prototype = Object.create(Error.prototype, {\r\n  name: { value: 'Eta Error', enumerable: false }\r\n})\r\n\r\n/**\r\n * Throws an EtaErr with a nicely formatted error and message showing where in the template the error occurred.\r\n */\r\n\r\nexport function ParseErr(message: string, str: string, indx: number): void {\r\n  const whitespace = str.slice(0, indx).split(/\\n/)\r\n\r\n  const lineNo = whitespace.length\r\n  const colNo = whitespace[lineNo - 1].length + 1\r\n  message +=\r\n    ' at line ' +\r\n    lineNo +\r\n    ' col ' +\r\n    colNo +\r\n    ':\\n\\n' +\r\n    '  ' +\r\n    str.split(/\\n/)[lineNo - 1] +\r\n    '\\n' +\r\n    '  ' +\r\n    Array(colNo).join(' ') +\r\n    '^'\r\n  throw EtaErr(message)\r\n}\r\n","import EtaErr from './err'\r\n\r\n/**\r\n * @returns The global Promise function\r\n */\r\n\r\nexport const promiseImpl: PromiseConstructor = new Function('return this')().Promise\r\n\r\n/**\r\n * @returns A new AsyncFunction constuctor\r\n */\r\n\r\nexport function getAsyncFunctionConstructor(): Function {\r\n  try {\r\n    return new Function('return (async function(){}).constructor')()\r\n  } catch (e) {\r\n    if (e instanceof SyntaxError) {\r\n      throw EtaErr(\"This environment doesn't support async/await\")\r\n    } else {\r\n      throw e\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * str.trimLeft polyfill\r\n *\r\n * @param str - Input string\r\n * @returns The string with left whitespace removed\r\n *\r\n */\r\n\r\nexport function trimLeft(str: string): string {\r\n  // eslint-disable-next-line no-extra-boolean-cast\r\n  if (!!String.prototype.trimLeft) {\r\n    return str.trimLeft()\r\n  } else {\r\n    return str.replace(/^\\s+/, '')\r\n  }\r\n}\r\n\r\n/**\r\n * str.trimRight polyfill\r\n *\r\n * @param str - Input string\r\n * @returns The string with right whitespace removed\r\n *\r\n */\r\n\r\nexport function trimRight(str: string): string {\r\n  // eslint-disable-next-line no-extra-boolean-cast\r\n  if (!!String.prototype.trimRight) {\r\n    return str.trimRight()\r\n  } else {\r\n    return str.replace(/\\s+$/, '') // TODO: do we really need to replace BOM's?\r\n  }\r\n}\r\n","// TODO: allow '-' to trim up until newline. Use [^\\S\\n\\r] instead of \\s\r\n// TODO: only include trimLeft polyfill if not in ES6\r\n\r\nimport { trimLeft, trimRight } from './polyfills'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig } from './config'\r\n\r\ninterface EscapeMap {\r\n  '&': '&amp;'\r\n  '<': '&lt;'\r\n  '>': '&gt;'\r\n  '\"': '&quot;'\r\n  \"'\": '&#39;'\r\n  [index: string]: string\r\n}\r\n\r\n/* END TYPES */\r\n\r\nexport function hasOwnProp(obj: object, prop: string): boolean {\r\n  return Object.prototype.hasOwnProperty.call(obj, prop)\r\n}\r\n\r\nexport function copyProps<T>(toObj: T, fromObj: T): T {\r\n  for (const key in fromObj) {\r\n    if (hasOwnProp((fromObj as unknown) as object, key)) {\r\n      toObj[key] = fromObj[key]\r\n    }\r\n  }\r\n  return toObj\r\n}\r\n\r\n/**\r\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\r\n */\r\n\r\nfunction trimWS(\r\n  str: string,\r\n  config: EtaConfig,\r\n  wsLeft: string | false,\r\n  wsRight?: string | false\r\n): string {\r\n  let leftTrim\r\n  let rightTrim\r\n\r\n  if (Array.isArray(config.autoTrim)) {\r\n    // kinda confusing\r\n    // but _}} will trim the left side of the following string\r\n    leftTrim = config.autoTrim[1]\r\n    rightTrim = config.autoTrim[0]\r\n  } else {\r\n    leftTrim = rightTrim = config.autoTrim\r\n  }\r\n\r\n  if (wsLeft || wsLeft === false) {\r\n    leftTrim = wsLeft\r\n  }\r\n\r\n  if (wsRight || wsRight === false) {\r\n    rightTrim = wsRight\r\n  }\r\n\r\n  if (!rightTrim && !leftTrim) {\r\n    return str\r\n  }\r\n\r\n  if (leftTrim === 'slurp' && rightTrim === 'slurp') {\r\n    return str.trim()\r\n  }\r\n\r\n  if (leftTrim === '_' || leftTrim === 'slurp') {\r\n    // console.log('trimming left' + leftTrim)\r\n    // full slurp\r\n\r\n    str = trimLeft(str)\r\n  } else if (leftTrim === '-' || leftTrim === 'nl') {\r\n    // nl trim\r\n    str = str.replace(/^(?:\\r\\n|\\n|\\r)/, '')\r\n  }\r\n\r\n  if (rightTrim === '_' || rightTrim === 'slurp') {\r\n    // full slurp\r\n    str = trimRight(str)\r\n  } else if (rightTrim === '-' || rightTrim === 'nl') {\r\n    // nl trim\r\n    str = str.replace(/(?:\\r\\n|\\n|\\r)$/, '') // TODO: make sure this gets \\r\\n\r\n  }\r\n\r\n  return str\r\n}\r\n\r\n/**\r\n * A map of special HTML characters to their XML-escaped equivalents\r\n */\r\n\r\nconst escMap: EscapeMap = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;'\r\n}\r\n\r\nfunction replaceChar(s: string): string {\r\n  return escMap[s]\r\n}\r\n\r\n/**\r\n * XML-escapes an input value after converting it to a string\r\n *\r\n * @param str - Input value (usually a string)\r\n * @returns XML-escaped string\r\n */\r\n\r\nfunction XMLEscape(str: any): string {\r\n  // eslint-disable-line @typescript-eslint/no-explicit-any\r\n  // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\r\n  const newStr = String(str)\r\n  if (/[&<>\"']/.test(newStr)) {\r\n    return newStr.replace(/[&<>\"']/g, replaceChar)\r\n  } else {\r\n    return newStr\r\n  }\r\n}\r\n\r\nexport { trimWS, XMLEscape }\r\n","import { ParseErr } from './err'\r\nimport { trimWS } from './utils'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig } from './config'\r\n\r\nexport type TagType = 'r' | 'e' | 'i' | ''\r\n\r\nexport interface TemplateObject {\r\n  t: TagType\r\n  val: string\r\n}\r\n\r\nexport type AstObject = string | TemplateObject\r\n\r\n/* END TYPES */\r\n\r\nconst templateLitReg = /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g\r\n\r\nconst singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g\r\n\r\nconst doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g\r\n\r\n/** Escape special regular expression characters inside a string */\r\n\r\nfunction escapeRegExp(string: string) {\r\n  // From MDN\r\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\r\n}\r\n\r\nexport default function parse(str: string, config: EtaConfig): Array<AstObject> {\r\n  let buffer: Array<AstObject> = []\r\n  let trimLeftOfNextStr: string | false = false\r\n  let lastIndex = 0\r\n  const parseOptions = config.parse\r\n\r\n  if (config.plugins) {\r\n    for (let i = 0; i < config.plugins.length; i++) {\r\n      const plugin = config.plugins[i]\r\n      if (plugin.processTemplate) {\r\n        str = plugin.processTemplate(str, config)\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Adding for EJS compatibility */\r\n  if (config.rmWhitespace) {\r\n    // Code taken directly from EJS\r\n    // Have to use two separate replaces here as `^` and `$` operators don't\r\n    // work well with `\\r` and empty lines don't work well with the `m` flag.\r\n    // Essentially, this replaces the whitespace at the beginning and end of\r\n    // each line and removes multiple newlines.\r\n    str = str.replace(/[\\r\\n]+/g, '\\n').replace(/^\\s+|\\s+$/gm, '')\r\n  }\r\n  /* End rmWhitespace option */\r\n\r\n  templateLitReg.lastIndex = 0\r\n  singleQuoteReg.lastIndex = 0\r\n  doubleQuoteReg.lastIndex = 0\r\n\r\n  function pushString(strng: string, shouldTrimRightOfString?: string | false) {\r\n    if (strng) {\r\n      // if string is truthy it must be of type 'string'\r\n\r\n      strng = trimWS(\r\n        strng,\r\n        config,\r\n        trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\r\n        shouldTrimRightOfString\r\n      )\r\n\r\n      if (strng) {\r\n        // replace \\ with \\\\, ' with \\'\r\n        // we're going to convert all CRLF to LF so it doesn't take more than one replace\r\n\r\n        strng = strng.replace(/\\\\|'/g, '\\\\$&').replace(/\\r\\n|\\n|\\r/g, '\\\\n')\r\n\r\n        buffer.push(strng)\r\n      }\r\n    }\r\n  }\r\n\r\n  const prefixes = [parseOptions.exec, parseOptions.interpolate, parseOptions.raw].reduce(function (\r\n    accumulator,\r\n    prefix\r\n  ) {\r\n    if (accumulator && prefix) {\r\n      return accumulator + '|' + escapeRegExp(prefix)\r\n    } else if (prefix) {\r\n      // accumulator is falsy\r\n      return escapeRegExp(prefix)\r\n    } else {\r\n      // prefix and accumulator are both falsy\r\n      return accumulator\r\n    }\r\n  },\r\n  '')\r\n\r\n  const parseOpenReg = new RegExp(\r\n    '([^]*?)' + escapeRegExp(config.tags[0]) + '(-|_)?\\\\s*(' + prefixes + ')?\\\\s*',\r\n    'g'\r\n  )\r\n\r\n  const parseCloseReg = new RegExp(\r\n    '\\'|\"|`|\\\\/\\\\*|(\\\\s*(-|_)?' + escapeRegExp(config.tags[1]) + ')',\r\n    'g'\r\n  )\r\n  // TODO: benchmark having the \\s* on either side vs using str.trim()\r\n\r\n  let m\r\n\r\n  while ((m = parseOpenReg.exec(str))) {\r\n    lastIndex = m[0].length + m.index\r\n\r\n    const precedingString = m[1]\r\n    const wsLeft = m[2]\r\n    const prefix = m[3] || '' // by default either ~, =, or empty\r\n\r\n    pushString(precedingString, wsLeft)\r\n\r\n    parseCloseReg.lastIndex = lastIndex\r\n    let closeTag\r\n    let currentObj: AstObject | false = false\r\n\r\n    while ((closeTag = parseCloseReg.exec(str))) {\r\n      if (closeTag[1]) {\r\n        let content = str.slice(lastIndex, closeTag.index)\r\n\r\n        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex\r\n\r\n        trimLeftOfNextStr = closeTag[2]\r\n\r\n        const currentType: TagType =\r\n          prefix === parseOptions.exec\r\n            ? 'e'\r\n            : prefix === parseOptions.raw\r\n            ? 'r'\r\n            : prefix === parseOptions.interpolate\r\n            ? 'i'\r\n            : ''\r\n\r\n        currentObj = { t: currentType, val: content }\r\n        break\r\n      } else {\r\n        const char = closeTag[0]\r\n        if (char === '/*') {\r\n          const commentCloseInd = str.indexOf('*/', parseCloseReg.lastIndex)\r\n\r\n          if (commentCloseInd === -1) {\r\n            ParseErr('unclosed comment', str, closeTag.index)\r\n          }\r\n          parseCloseReg.lastIndex = commentCloseInd\r\n        } else if (char === \"'\") {\r\n          singleQuoteReg.lastIndex = closeTag.index\r\n\r\n          const singleQuoteMatch = singleQuoteReg.exec(str)\r\n          if (singleQuoteMatch) {\r\n            parseCloseReg.lastIndex = singleQuoteReg.lastIndex\r\n          } else {\r\n            ParseErr('unclosed string', str, closeTag.index)\r\n          }\r\n        } else if (char === '\"') {\r\n          doubleQuoteReg.lastIndex = closeTag.index\r\n          const doubleQuoteMatch = doubleQuoteReg.exec(str)\r\n\r\n          if (doubleQuoteMatch) {\r\n            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex\r\n          } else {\r\n            ParseErr('unclosed string', str, closeTag.index)\r\n          }\r\n        } else if (char === '`') {\r\n          templateLitReg.lastIndex = closeTag.index\r\n          const templateLitMatch = templateLitReg.exec(str)\r\n          if (templateLitMatch) {\r\n            parseCloseReg.lastIndex = templateLitReg.lastIndex\r\n          } else {\r\n            ParseErr('unclosed string', str, closeTag.index)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (currentObj) {\r\n      buffer.push(currentObj)\r\n    } else {\r\n      ParseErr('unclosed tag', str, m.index + precedingString.length)\r\n    }\r\n  }\r\n\r\n  pushString(str.slice(lastIndex, str.length), false)\r\n\r\n  if (config.plugins) {\r\n    for (let i = 0; i < config.plugins.length; i++) {\r\n      const plugin = config.plugins[i]\r\n      if (plugin.processAST) {\r\n        buffer = plugin.processAST(buffer, config)\r\n      }\r\n    }\r\n  }\r\n\r\n  return buffer\r\n}\r\n","import Parse from './parse'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig } from './config'\r\nimport type { AstObject } from './parse'\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\r\n *\r\n * **Example**\r\n *\r\n * ```js\r\n * compileToString(\"Hi <%= it.user %>\", eta.config)\r\n * // \"var tR='',include=E.include.bind(E),includeFile=E.includeFile.bind(E);tR+='Hi ';tR+=E.e(it.user);if(cb){cb(null,tR)} return tR\"\r\n * ```\r\n */\r\n\r\nexport default function compileToString(str: string, config: EtaConfig): string {\r\n  const buffer: Array<AstObject> = Parse(str, config)\r\n\r\n  let res =\r\n    \"var tR='',__l,__lP\" +\r\n    (config.include ? ',include=E.include.bind(E)' : '') +\r\n    (config.includeFile ? ',includeFile=E.includeFile.bind(E)' : '') +\r\n    '\\nfunction layout(p,d){__l=p;__lP=d}\\n' +\r\n    (config.useWith ? 'with(' + config.varName + '||{}){' : '') +\r\n    compileScope(buffer, config) +\r\n    (config.includeFile\r\n      ? 'if(__l)tR=' +\r\n        (config.async ? 'await ' : '') +\r\n        `includeFile(__l,Object.assign(${config.varName},{body:tR},__lP))\\n`\r\n      : config.include\r\n      ? 'if(__l)tR=' +\r\n        (config.async ? 'await ' : '') +\r\n        `include(__l,Object.assign(${config.varName},{body:tR},__lP))\\n`\r\n      : '') +\r\n    'if(cb){cb(null,tR)} return tR' +\r\n    (config.useWith ? '}' : '')\r\n\r\n  if (config.plugins) {\r\n    for (let i = 0; i < config.plugins.length; i++) {\r\n      const plugin = config.plugins[i]\r\n      if (plugin.processFnString) {\r\n        res = plugin.processFnString(res, config)\r\n      }\r\n    }\r\n  }\r\n\r\n  return res\r\n}\r\n\r\n/**\r\n * Loops through the AST generated by `parse` and transform each item into JS calls\r\n *\r\n * **Example**\r\n *\r\n * ```js\r\n * // AST version of 'Hi <%= it.user %>'\r\n * let templateAST = ['Hi ', { val: 'it.user', t: 'i' }]\r\n * compileScope(templateAST, eta.config)\r\n * // \"tR+='Hi ';tR+=E.e(it.user);\"\r\n * ```\r\n */\r\n\r\nfunction compileScope(buff: Array<AstObject>, config: EtaConfig) {\r\n  let i = 0\r\n  const buffLength = buff.length\r\n  let returnStr = ''\r\n\r\n  for (i; i < buffLength; i++) {\r\n    const currentBlock = buff[i]\r\n    if (typeof currentBlock === 'string') {\r\n      const str = currentBlock\r\n\r\n      // we know string exists\r\n      returnStr += \"tR+='\" + str + \"'\\n\"\r\n    } else {\r\n      const type = currentBlock.t // ~, s, !, ?, r\r\n      let content = currentBlock.val || ''\r\n\r\n      if (type === 'r') {\r\n        // raw\r\n\r\n        if (config.filter) {\r\n          content = 'E.filter(' + content + ')'\r\n        }\r\n\r\n        returnStr += 'tR+=' + content + '\\n'\r\n      } else if (type === 'i') {\r\n        // interpolate\r\n\r\n        if (config.filter) {\r\n          content = 'E.filter(' + content + ')'\r\n        }\r\n\r\n        if (config.autoEscape) {\r\n          content = 'E.e(' + content + ')'\r\n        }\r\n        returnStr += 'tR+=' + content + '\\n'\r\n        // reference\r\n      } else if (type === 'e') {\r\n        // execute\r\n        returnStr += content + '\\n' // you need a \\n in case you have <% } %>\r\n      }\r\n    }\r\n  }\r\n\r\n  return returnStr\r\n}\r\n","import { copyProps } from './utils'\r\n\r\n/**\r\n * Handles storage and accessing of values\r\n *\r\n * In this case, we use it to store compiled template functions\r\n * Indexed by their `name` or `filename`\r\n */\r\nclass Cacher<T> {\r\n  constructor(private cache: Record<string, T>) {}\r\n  define(key: string, val: T): void {\r\n    this.cache[key] = val\r\n  }\r\n  get(key: string): T {\r\n    // string | array.\r\n    // TODO: allow array of keys to look down\r\n    // TODO: create plugin to allow referencing helpers, filters with dot notation\r\n    return this.cache[key]\r\n  }\r\n  remove(key: string): void {\r\n    delete this.cache[key]\r\n  }\r\n  reset(): void {\r\n    this.cache = {}\r\n  }\r\n  load(cacheObj: Record<string, T>): void {\r\n    copyProps(this.cache, cacheObj)\r\n  }\r\n}\r\n\r\nexport { Cacher }\r\n","import { Cacher } from './storage'\r\n\r\n/* TYPES */\r\n\r\nimport type { TemplateFunction } from './compile'\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Eta's template storage\r\n *\r\n * Stores partials and cached templates\r\n */\r\n\r\nconst templates = new Cacher<TemplateFunction>({})\r\n\r\nexport { templates }\r\n","import { templates } from './containers'\r\nimport { copyProps, XMLEscape } from './utils'\r\nimport EtaErr from './err'\r\n\r\n/* TYPES */\r\n\r\nimport type { TemplateFunction } from './compile'\r\nimport type { Cacher } from './storage'\r\n\r\ntype trimConfig = 'nl' | 'slurp' | false\r\n\r\nexport interface EtaConfig {\r\n  /** Whether or not to automatically XML-escape interpolations. Default true */\r\n  autoEscape: boolean\r\n\r\n  /** Configure automatic whitespace trimming. Default `[false, 'nl']` */\r\n  autoTrim: trimConfig | [trimConfig, trimConfig]\r\n\r\n  /** Compile to async function */\r\n  async: boolean\r\n\r\n  /** Whether or not to cache templates if `name` or `filename` is passed */\r\n  cache: boolean\r\n\r\n  /** XML-escaping function */\r\n  e: (str: string) => string\r\n\r\n  /** Parsing options */\r\n  parse: {\r\n    /** Which prefix to use for evaluation. Default `\"\"` */\r\n    exec: string\r\n\r\n    /** Which prefix to use for interpolation. Default `\"=\"` */\r\n    interpolate: string\r\n\r\n    /** Which prefix to use for raw interpolation. Default `\"~\"` */\r\n    raw: string\r\n  }\r\n\r\n  /** Array of plugins */\r\n  plugins: Array<{ processFnString?: Function; processAST?: Function; processTemplate?: Function }>\r\n\r\n  /** Remove all safe-to-remove whitespace */\r\n  rmWhitespace: boolean\r\n\r\n  /** Delimiters: by default `['<%', '%>']` */\r\n  tags: [string, string]\r\n\r\n  /** Holds template cache */\r\n  templates: Cacher<TemplateFunction>\r\n\r\n  /** Name of the data object. Default `it` */\r\n  varName: string\r\n\r\n  /** Absolute path to template file */\r\n  filename?: string\r\n\r\n  /** Holds cache of resolved filepaths. Set to `false` to disable */\r\n  filepathCache?: Record<string, string> | false\r\n\r\n  /** A filter function applied to every interpolation or raw interpolation */\r\n  filter?: Function\r\n\r\n  /** Function to include templates by name */\r\n  include?: Function\r\n\r\n  /** Function to include templates by filepath */\r\n  includeFile?: Function\r\n\r\n  /** Name of template */\r\n  name?: string\r\n\r\n  /** Where should absolute paths begin? Default '/' */\r\n  root?: string\r\n\r\n  /** Make data available on the global object instead of varName */\r\n  useWith?: boolean\r\n\r\n  /** Whether or not to cache templates if `name` or `filename` is passed: duplicate of `cache` */\r\n  'view cache'?: boolean\r\n\r\n  /** Directory or directories that contain templates */\r\n  views?: string | Array<string>\r\n\r\n  [index: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\r\n}\r\n\r\nexport interface EtaConfigWithFilename extends EtaConfig {\r\n  filename: string\r\n}\r\n\r\nexport type PartialConfig = Partial<EtaConfig>\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Include a template based on its name (or filepath, if it's already been cached).\r\n *\r\n * Called like `include(templateNameOrPath, data)`\r\n */\r\n\r\nfunction includeHelper(this: EtaConfig, templateNameOrPath: string, data: object): string {\r\n  const template = this.templates.get(templateNameOrPath)\r\n  if (!template) {\r\n    throw EtaErr('Could not fetch template \"' + templateNameOrPath + '\"')\r\n  }\r\n  return template(data, this)\r\n}\r\n\r\n/** Eta's base (global) configuration */\r\nconst config: EtaConfig = {\r\n  async: false,\r\n  autoEscape: true,\r\n  autoTrim: [false, 'nl'],\r\n  cache: false,\r\n  e: XMLEscape,\r\n  include: includeHelper,\r\n  parse: {\r\n    exec: '',\r\n    interpolate: '=',\r\n    raw: '~'\r\n  },\r\n  plugins: [],\r\n  rmWhitespace: false,\r\n  tags: ['<%', '%>'],\r\n  templates: templates,\r\n  useWith: false,\r\n  varName: 'it'\r\n}\r\n\r\n/**\r\n * Takes one or two partial (not necessarily complete) configuration objects, merges them 1 layer deep into eta.config, and returns the result\r\n *\r\n * @param override Partial configuration object\r\n * @param baseConfig Partial configuration object to merge before `override`\r\n *\r\n * **Example**\r\n *\r\n * ```js\r\n * let customConfig = getConfig({tags: ['!#', '#!']})\r\n * ```\r\n */\r\n\r\nfunction getConfig(override: PartialConfig, baseConfig?: EtaConfig): EtaConfig {\r\n  // TODO: run more tests on this\r\n\r\n  const res: PartialConfig = {} // Linked\r\n  copyProps(res, config) // Creates deep clone of eta.config, 1 layer deep\r\n\r\n  if (baseConfig) {\r\n    copyProps(res, baseConfig)\r\n  }\r\n\r\n  if (override) {\r\n    copyProps(res, override)\r\n  }\r\n\r\n  return res as EtaConfig\r\n}\r\n\r\n/** Update Eta's base config */\r\n\r\nfunction configure(options: PartialConfig): Partial<EtaConfig> {\r\n  return copyProps(config, options)\r\n}\r\n\r\nexport { config, getConfig, configure }\r\n","import compileToString from './compile-string'\r\nimport { getConfig } from './config'\r\nimport EtaErr from './err'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig, PartialConfig } from './config'\r\nimport type { CallbackFn } from './file-handlers'\r\nimport { getAsyncFunctionConstructor } from './polyfills'\r\nexport type TemplateFunction = (data: object, config: EtaConfig, cb?: CallbackFn) => string\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Takes a template string and returns a template function that can be called with (data, config, [cb])\r\n *\r\n * @param str - The template string\r\n * @param config - A custom configuration object (optional)\r\n *\r\n * **Example**\r\n *\r\n * ```js\r\n * let compiledFn = eta.compile(\"Hi <%= it.user %>\")\r\n * // function anonymous()\r\n * let compiledFnStr = compiledFn.toString()\r\n * // \"function anonymous(it,E,cb\\n) {\\nvar tR='',include=E.include.bind(E),includeFile=E.includeFile.bind(E);tR+='Hi ';tR+=E.e(it.user);if(cb){cb(null,tR)} return tR\\n}\"\r\n * ```\r\n */\r\n\r\nexport default function compile(str: string, config?: PartialConfig): TemplateFunction {\r\n  const options: EtaConfig = getConfig(config || {})\r\n\r\n  /* ASYNC HANDLING */\r\n  // The below code is modified from mde/ejs. All credit should go to them.\r\n  const ctor = options.async ? (getAsyncFunctionConstructor() as FunctionConstructor) : Function\r\n  /* END ASYNC HANDLING */\r\n\r\n  try {\r\n    return new ctor(\r\n      options.varName,\r\n      'E', // EtaConfig\r\n      'cb', // optional callback\r\n      compileToString(str, options)\r\n    ) as TemplateFunction // eslint-disable-line no-new-func\r\n  } catch (e) {\r\n    if (e instanceof SyntaxError) {\r\n      throw EtaErr(\r\n        'Bad template syntax\\n\\n' +\r\n          e.message +\r\n          '\\n' +\r\n          Array(e.message.length + 1).join('=') +\r\n          '\\n' +\r\n          compileToString(str, options) +\r\n          '\\n' // This will put an extra newline before the callstack for extra readability\r\n      )\r\n    } else {\r\n      throw e\r\n    }\r\n  }\r\n}\r\n","import { path, existsSync, readFileSync } from './file-methods'\r\nconst _BOM = /^\\uFEFF/\r\n\r\n// express is set like: app.engine('html', require('eta').renderFile)\r\n\r\nimport EtaErr from './err'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig } from './config'\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Get the path to the included file from the parent file path and the\r\n * specified path.\r\n *\r\n * If `name` does not have an extension, it will default to `.eta`\r\n *\r\n * @param name specified path\r\n * @param parentfile parent file path\r\n * @param isDirectory whether parentfile is a directory\r\n * @return absolute path to template\r\n */\r\n\r\nfunction getWholeFilePath(name: string, parentfile: string, isDirectory?: boolean): string {\r\n  const includePath =\r\n    path.resolve(\r\n      isDirectory ? parentfile : path.dirname(parentfile), // returns directory the parent file is in\r\n      name // file\r\n    ) + (path.extname(name) ? '' : '.eta')\r\n  return includePath\r\n}\r\n\r\n/**\r\n * Get the absolute path to an included template\r\n *\r\n * If this is called with an absolute path (for example, starting with '/' or 'C:\\')\r\n * then Eta will attempt to resolve the absolute path within options.views. If it cannot,\r\n * Eta will fallback to options.root or '/'\r\n *\r\n * If this is called with a relative path, Eta will:\r\n * - Look relative to the current template (if the current template has the `filename` property)\r\n * - Look inside each directory in options.views\r\n *\r\n * Note: if Eta is unable to find a template using path and options, it will throw an error.\r\n *\r\n * @param path    specified path\r\n * @param options compilation options\r\n * @return absolute path to template\r\n */\r\n\r\nfunction getPath(path: string, options: EtaConfig): string {\r\n  let includePath: string | false = false\r\n  const views = options.views\r\n  let searchedPaths: Array<string> = []\r\n\r\n  // If these four values are the same,\r\n  // getPath() will return the same result every time.\r\n  // We can cache the result to avoid expensive\r\n  // file operations.\r\n  const pathOptions = JSON.stringify({\r\n    filename: options.filename, // filename of the template which called includeFile()\r\n    path: path,\r\n    root: options.root,\r\n    views: options.views\r\n  })\r\n\r\n  if (options.cache && options.filepathCache && options.filepathCache[pathOptions]) {\r\n    // Use the cached filepath\r\n    return options.filepathCache[pathOptions]\r\n  }\r\n\r\n  /** Add a filepath to the list of paths we've checked for a template */\r\n  function addPathToSearched(pathSearched: string) {\r\n    if (!searchedPaths.includes(pathSearched)) {\r\n      searchedPaths.push(pathSearched)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Take a filepath (like 'partials/mypartial.eta'). Attempt to find the template file inside `views`;\r\n   * return the resulting template file path, or `false` to indicate that the template was not found.\r\n   *\r\n   * @param views the filepath that holds templates, or an array of filepaths that hold templates\r\n   * @param path the path to the template\r\n   */\r\n\r\n  function searchViews(views: Array<string> | string | undefined, path: string): string | false {\r\n    let filePath\r\n\r\n    // If views is an array, then loop through each directory\r\n    // And attempt to find the template\r\n    if (\r\n      Array.isArray(views) &&\r\n      views.some(function (v) {\r\n        filePath = getWholeFilePath(path, v, true)\r\n\r\n        addPathToSearched(filePath)\r\n\r\n        return existsSync(filePath)\r\n      })\r\n    ) {\r\n      // If the above returned true, we know that the filePath was just set to a path\r\n      // That exists (Array.some() returns as soon as it finds a valid element)\r\n      return (filePath as unknown) as string\r\n    } else if (typeof views === 'string') {\r\n      // Search for the file if views is a single directory\r\n      filePath = getWholeFilePath(path, views, true)\r\n\r\n      addPathToSearched(filePath)\r\n\r\n      if (existsSync(filePath)) {\r\n        return filePath\r\n      }\r\n    }\r\n\r\n    // Unable to find a file\r\n    return false\r\n  }\r\n\r\n  // Path starts with '/', 'C:\\', etc.\r\n  const match = /^[A-Za-z]+:\\\\|^\\//.exec(path)\r\n\r\n  // Absolute path, like /partials/partial.eta\r\n  if (match && match.length) {\r\n    // We have to trim the beginning '/' off the path, or else\r\n    // path.resolve(dir, path) will always resolve to just path\r\n    const formattedPath = path.replace(/^\\/*/, '')\r\n\r\n    // First, try to resolve the path within options.views\r\n    includePath = searchViews(views, formattedPath)\r\n    if (!includePath) {\r\n      // If that fails, searchViews will return false. Try to find the path\r\n      // inside options.root (by default '/', the base of the filesystem)\r\n      const pathFromRoot = getWholeFilePath(formattedPath, options.root || '/', true)\r\n\r\n      addPathToSearched(pathFromRoot)\r\n\r\n      includePath = pathFromRoot\r\n    }\r\n  } else {\r\n    // Relative paths\r\n    // Look relative to a passed filename first\r\n    if (options.filename) {\r\n      const filePath = getWholeFilePath(path, options.filename)\r\n\r\n      addPathToSearched(filePath)\r\n\r\n      if (existsSync(filePath)) {\r\n        includePath = filePath\r\n      }\r\n    }\r\n    // Then look for the template in options.views\r\n    if (!includePath) {\r\n      includePath = searchViews(views, path)\r\n    }\r\n    if (!includePath) {\r\n      throw EtaErr('Could not find the template \"' + path + '\". Paths tried: ' + searchedPaths)\r\n    }\r\n  }\r\n\r\n  // If caching and filepathCache are enabled,\r\n  // cache the input & output of this function.\r\n  if (options.cache && options.filepathCache) {\r\n    options.filepathCache[pathOptions] = includePath\r\n  }\r\n\r\n  return includePath\r\n}\r\n\r\n/**\r\n * Reads a file synchronously\r\n */\r\n\r\nfunction readFile(filePath: string): string {\r\n  try {\r\n    return readFileSync(filePath).toString().replace(_BOM, '') // TODO: is replacing BOM's necessary?\r\n  } catch {\r\n    throw EtaErr(\"Failed to read template at '\" + filePath + \"'\")\r\n  }\r\n}\r\n\r\nexport { getPath, readFile }\r\n","// express is set like: app.engine('html', require('eta').renderFile)\r\n\r\nimport EtaErr from './err'\r\nimport compile from './compile'\r\nimport { getConfig } from './config'\r\nimport { getPath, readFile } from './file-utils'\r\nimport { copyProps } from './utils'\r\nimport { promiseImpl } from './polyfills'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig, PartialConfig, EtaConfigWithFilename } from './config'\r\nimport type { TemplateFunction } from './compile'\r\n\r\nexport type CallbackFn = (err: Error | null, str?: string) => void\r\n\r\ninterface DataObj {\r\n  /** Express.js settings may be stored here */\r\n  settings?: {\r\n    [key: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\r\n  }\r\n  [key: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\r\n}\r\n\r\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\r\n  filename: string\r\n}\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\r\n *\r\n * @param filePath Absolute path to template file\r\n * @param options Eta configuration overrides\r\n * @param noCache Optionally, make Eta not cache the template\r\n */\r\n\r\nexport function loadFile(\r\n  filePath: string,\r\n  options: PartialConfigWithFilename,\r\n  noCache?: boolean\r\n): TemplateFunction {\r\n  const config = getConfig(options)\r\n  const template = readFile(filePath)\r\n  try {\r\n    const compiledTemplate = compile(template, config)\r\n    if (!noCache) {\r\n      config.templates.define((config as EtaConfigWithFilename).filename, compiledTemplate)\r\n    }\r\n    return compiledTemplate\r\n  } catch (e) {\r\n    throw EtaErr('Loading file: ' + filePath + ' failed:\\n\\n' + e.message)\r\n  }\r\n}\r\n\r\n/**\r\n * Get the template from a string or a file, either compiled on-the-fly or\r\n * read from cache (if enabled), and cache the template if needed.\r\n *\r\n * If `options.cache` is true, this function reads the file from\r\n * `options.filename` so it must be set prior to calling this function.\r\n *\r\n * @param options   compilation options\r\n * @return Eta template function\r\n */\r\n\r\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\r\n  const filename = options.filename\r\n\r\n  if (options.cache) {\r\n    const func = options.templates.get(filename)\r\n    if (func) {\r\n      return func\r\n    }\r\n\r\n    return loadFile(filename, options)\r\n  }\r\n\r\n  // Caching is disabled, so pass noCache = true\r\n  return loadFile(filename, options, true)\r\n}\r\n\r\n/**\r\n * Try calling handleCache with the given options and data and call the\r\n * callback with the result. If an error occurs, call the callback with\r\n * the error. Used by renderFile().\r\n *\r\n * @param data template data\r\n * @param options compilation options\r\n * @param cb callback\r\n */\r\n\r\nfunction tryHandleCache(data: object, options: EtaConfigWithFilename, cb: CallbackFn | undefined) {\r\n  if (cb) {\r\n    try {\r\n      // Note: if there is an error while rendering the template,\r\n      // It will bubble up and be caught here\r\n      const templateFn = handleCache(options)\r\n      templateFn(data, options, cb)\r\n    } catch (err) {\r\n      return cb(err)\r\n    }\r\n  } else {\r\n    // No callback, try returning a promise\r\n    if (typeof promiseImpl === 'function') {\r\n      return new promiseImpl<string>(function (resolve: Function, reject: Function) {\r\n        try {\r\n          const templateFn = handleCache(options)\r\n          const result = templateFn(data, options)\r\n          resolve(result)\r\n        } catch (err) {\r\n          reject(err)\r\n        }\r\n      })\r\n    } else {\r\n      throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\")\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get the template function.\r\n *\r\n * If `options.cache` is `true`, then the template is cached.\r\n *\r\n * This returns a template function and the config object with which that template function should be called.\r\n *\r\n * @remarks\r\n *\r\n * It's important that this returns a config object with `filename` set.\r\n * Otherwise, the included file would not be able to use relative paths\r\n *\r\n * @param path path for the specified file (if relative, specify `views` on `options`)\r\n * @param options compilation options\r\n * @return [Eta template function, new config object]\r\n */\r\n\r\nfunction includeFile(path: string, options: EtaConfig): [TemplateFunction, EtaConfig] {\r\n  // the below creates a new options object, using the parent filepath of the old options object and the path\r\n  const newFileOptions = getConfig({ filename: getPath(path, options) }, options)\r\n  // TODO: make sure properties are currectly copied over\r\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions]\r\n}\r\n\r\n/**\r\n * Render a template from a filepath.\r\n *\r\n * @param filepath Path to template file. If relative, specify `views` on the config object\r\n *\r\n * This can take two different function signatures:\r\n *\r\n * - `renderFile(filename, dataAndConfig, [cb])`\r\n *   - Eta will merge `dataAndConfig` into `eta.config`\r\n * - `renderFile(filename, data, [config], [cb])`\r\n *\r\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\r\n *\r\n * **Examples**\r\n *\r\n * ```js\r\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\r\n *   if (err) console.log(err)\r\n *   console.log(rendered)\r\n * })\r\n *\r\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\r\n *\r\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\r\n * ```\r\n */\r\n\r\nfunction renderFile(\r\n  filename: string,\r\n  data: DataObj,\r\n  config?: PartialConfig,\r\n  cb?: CallbackFn\r\n): Promise<string> | void\r\n\r\nfunction renderFile(filename: string, data: DataObj, cb?: CallbackFn): Promise<string> | void\r\n\r\nfunction renderFile(\r\n  filename: string,\r\n  data: DataObj,\r\n  config?: PartialConfig,\r\n  cb?: CallbackFn\r\n): Promise<string> | void {\r\n  /*\r\n  Here we have some function overloading.\r\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\r\n  However, with Express, configuration options will be passed along with the data.\r\n  Thus, Express will call renderFile with (filename, dataAndOptions, cb)\r\n  And we want to also make (filename, data, options, cb) available\r\n  */\r\n\r\n  let renderConfig: EtaConfigWithFilename\r\n  let callback: CallbackFn | undefined\r\n  data = data || {} // If data is undefined, we don't want accessing data.settings to error\r\n\r\n  // First, assign our callback function to `callback`\r\n  // We can leave it undefined if neither parameter is a function;\r\n  // Callbacks are optional\r\n  if (typeof cb === 'function') {\r\n    // The 4th argument is the callback\r\n    callback = cb\r\n  } else if (typeof config === 'function') {\r\n    // The 3rd arg is the callback\r\n    callback = config\r\n  }\r\n\r\n  // If there is a config object passed in explicitly, use it\r\n  if (typeof config === 'object') {\r\n    renderConfig = getConfig((config as PartialConfig) || {}) as EtaConfigWithFilename\r\n  } else {\r\n    // Otherwise, get the config from the data object\r\n    // And then grab some config options from data.settings\r\n    // Which is where Express sometimes stores them\r\n    renderConfig = getConfig(data as PartialConfig) as EtaConfigWithFilename\r\n    if (data.settings) {\r\n      // Pull a few things from known locations\r\n      if (data.settings.views) {\r\n        renderConfig.views = data.settings.views\r\n      }\r\n      if (data.settings['view cache']) {\r\n        renderConfig.cache = true\r\n      }\r\n      // Undocumented after Express 2, but still usable, esp. for\r\n      // items that are unsafe to be passed along with data, like `root`\r\n      const viewOpts = data.settings['view options']\r\n\r\n      if (viewOpts) {\r\n        copyProps(renderConfig, viewOpts)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Set the filename option on the template\r\n  // This will first try to resolve the file path (see getPath for details)\r\n  renderConfig.filename = getPath(filename, renderConfig)\r\n\r\n  return tryHandleCache(data, renderConfig, callback)\r\n}\r\n\r\n/**\r\n * Render a template from a filepath asynchronously.\r\n *\r\n * @param filepath Path to template file. If relative, specify `views` on the config object\r\n *\r\n * This can take two different function signatures:\r\n *\r\n * - `renderFile(filename, dataAndConfig, [cb])`\r\n *   - Eta will merge `dataAndConfig` into `eta.config`\r\n * - `renderFile(filename, data, [config], [cb])`\r\n *\r\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\r\n *\r\n * **Examples**\r\n *\r\n * ```js\r\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\r\n *   if (err) console.log(err)\r\n *   console.log(rendered)\r\n * })\r\n *\r\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\r\n *\r\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\r\n * ```\r\n */\r\n\r\nfunction renderFileAsync(\r\n  filename: string,\r\n  data: DataObj,\r\n  config?: PartialConfig,\r\n  cb?: CallbackFn\r\n): Promise<string> | void\r\n\r\nfunction renderFileAsync(filename: string, data: DataObj, cb?: CallbackFn): Promise<string> | void\r\n\r\nfunction renderFileAsync(\r\n  filename: string,\r\n  data: DataObj,\r\n  config?: PartialConfig,\r\n  cb?: CallbackFn\r\n): Promise<string> | void {\r\n  return renderFile(\r\n    filename,\r\n    typeof config === 'function' ? { ...data, async: true } : data,\r\n    typeof config === 'object' ? { ...config, async: true } : config,\r\n    cb\r\n  )\r\n}\r\n\r\nexport { includeFile, renderFile, renderFileAsync }\r\n","import { includeFile } from './file-handlers'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig } from './config'\r\n\r\ninterface GenericData {\r\n  [index: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\r\n}\r\n\r\n/* END TYPES */\r\n\r\n/**\r\n * Called with `includeFile(path, data)`\r\n */\r\n\r\nexport function includeFileHelper(this: EtaConfig, path: string, data: GenericData): string {\r\n  const templateAndConfig = includeFile(path, this)\r\n  return templateAndConfig[0](data, templateAndConfig[1])\r\n}\r\n","import compile from './compile'\r\nimport { getConfig } from './config'\r\nimport { promiseImpl } from './polyfills'\r\nimport EtaErr from './err'\r\n\r\n/* TYPES */\r\n\r\nimport type { EtaConfig, PartialConfig } from './config'\r\nimport type { TemplateFunction } from './compile'\r\nimport type { CallbackFn } from './file-handlers'\r\n\r\n/* END TYPES */\r\n\r\nfunction handleCache(template: string | TemplateFunction, options: EtaConfig): TemplateFunction {\r\n  if (options.cache && options.name && options.templates.get(options.name)) {\r\n    return options.templates.get(options.name)\r\n  }\r\n\r\n  const templateFunc = typeof template === 'function' ? template : compile(template, options)\r\n\r\n  // Note that we don't have to check if it already exists in the cache;\r\n  // it would have returned earlier if it had\r\n  if (options.cache && options.name) {\r\n    options.templates.define(options.name, templateFunc)\r\n  }\r\n\r\n  return templateFunc\r\n}\r\n\r\n/**\r\n * Render a template\r\n *\r\n * If `template` is a string, Eta will compile it to a function and then call it with the provided data.\r\n * If `template` is a template function, Eta will call it with the provided data.\r\n *\r\n * If `config.async` is `false`, Eta will return the rendered template.\r\n *\r\n * If `config.async` is `true` and there's a callback function, Eta will call the callback with `(err, renderedTemplate)`.\r\n * If `config.async` is `true` and there's not a callback function, Eta will return a Promise that resolves to the rendered template.\r\n *\r\n * If `config.cache` is `true` and `config` has a `name` or `filename` property, Eta will cache the template on the first render and use the cached template for all subsequent renders.\r\n *\r\n * @param template Template string or template function\r\n * @param data Data to render the template with\r\n * @param config Optional config options\r\n * @param cb Callback function\r\n */\r\n\r\nexport default function render(\r\n  template: string | TemplateFunction,\r\n  data: object,\r\n  config?: PartialConfig,\r\n  cb?: CallbackFn\r\n): string | Promise<string> | void {\r\n  const options = getConfig(config || {})\r\n\r\n  if (options.async) {\r\n    if (cb) {\r\n      // If user passes callback\r\n      try {\r\n        // Note: if there is an error while rendering the template,\r\n        // It will bubble up and be caught here\r\n        const templateFn = handleCache(template, options)\r\n        templateFn(data, options, cb)\r\n      } catch (err) {\r\n        return cb(err)\r\n      }\r\n    } else {\r\n      // No callback, try returning a promise\r\n      if (typeof promiseImpl === 'function') {\r\n        return new promiseImpl(function (resolve: Function, reject: Function) {\r\n          try {\r\n            resolve(handleCache(template, options)(data, options))\r\n          } catch (err) {\r\n            reject(err)\r\n          }\r\n        })\r\n      } else {\r\n        throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\")\r\n      }\r\n    }\r\n  } else {\r\n    return handleCache(template, options)(data, options)\r\n  }\r\n}\r\n\r\n/**\r\n * Render a template asynchronously\r\n *\r\n * If `template` is a string, Eta will compile it to a function and call it with the provided data.\r\n * If `template` is a function, Eta will call it with the provided data.\r\n *\r\n * If there is a callback function, Eta will call it with `(err, renderedTemplate)`.\r\n * If there is not a callback function, Eta will return a Promise that resolves to the rendered template\r\n *\r\n * @param template Template string or template function\r\n * @param data Data to render the template with\r\n * @param config Optional config options\r\n * @param cb Callback function\r\n */\r\n\r\nexport function renderAsync(\r\n  template: string | TemplateFunction,\r\n  data: object,\r\n  config?: PartialConfig,\r\n  cb?: CallbackFn\r\n): string | Promise<string> | void {\r\n  // Using Object.assign to lower bundle size, using spread operator makes it larger because of typescript injected polyfills\r\n  return render(template, data, Object.assign({}, config, { async: true }), cb)\r\n}\r\n","// @denoify-ignore\r\n\r\n/* Export file stuff */\r\nimport { includeFileHelper } from './file-helpers'\r\nimport { config } from './config'\r\n\r\nconfig.includeFile = includeFileHelper\r\nconfig.filepathCache = {}\r\n\r\nexport { loadFile, renderFile, renderFileAsync, renderFile as __express } from './file-handlers'\r\n\r\n/* End file stuff */\r\n\r\nexport { default as compileToString } from './compile-string'\r\nexport { default as compile } from './compile'\r\nexport { default as parse } from './parse'\r\nexport { default as render, renderAsync } from './render'\r\nexport { templates } from './containers'\r\nexport { config, config as defaultConfig, getConfig, configure } from './config'\r\n"],"names":["Parse","path.resolve","path.dirname","path.extname","handleCache"],"mappings":"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"}