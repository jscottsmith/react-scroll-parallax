"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSidebars = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
const generator_1 = require("./generator");
const lodash_1 = require("lodash");
const combine_promises_1 = (0, tslib_1.__importDefault)(require("combine-promises"));
const normalization_1 = require("./normalization");
function toSidebarItemsGeneratorDoc(doc) {
    return (0, lodash_1.pick)(doc, [
        'id',
        'unversionedId',
        'frontMatter',
        'source',
        'sourceDirName',
        'sidebarPosition',
    ]);
}
function toSidebarItemsGeneratorVersion(version) {
    return (0, lodash_1.pick)(version, ['versionName', 'contentPath']);
}
// Handle the generation of autogenerated sidebar items and other post-processing checks
async function processSidebar(unprocessedSidebar, params) {
    const { sidebarItemsGenerator, numberPrefixParser, docs, version, sidebarOptions, } = params;
    // Just a minor lazy transformation optimization
    const getSidebarItemsGeneratorDocsAndVersion = (0, lodash_1.memoize)(() => ({
        docs: docs.map(toSidebarItemsGeneratorDoc),
        version: toSidebarItemsGeneratorVersion(version),
    }));
    async function processCategoryItem(item) {
        return {
            ...item,
            items: (await Promise.all(item.items.map(processItem))).flat(),
        };
    }
    async function processAutoGeneratedItem(item) {
        // TODO the returned type can't be trusted in practice (generator can be user-provided)
        const generatedItems = await sidebarItemsGenerator({
            item,
            numberPrefixParser,
            defaultSidebarItemsGenerator: generator_1.DefaultSidebarItemsGenerator,
            ...getSidebarItemsGeneratorDocsAndVersion(),
            options: sidebarOptions,
        });
        // TODO validate generated items: user can generate bad items
        const generatedItemsNormalized = generatedItems.flatMap((generatedItem) => (0, normalization_1.normalizeItem)(generatedItem, { ...params, ...sidebarOptions }));
        // Process again... weird but sidebar item generated might generate some auto-generated items?
        return processItems(generatedItemsNormalized);
    }
    async function processItem(item) {
        if (item.type === 'category') {
            return [await processCategoryItem(item)];
        }
        if (item.type === 'autogenerated') {
            return processAutoGeneratedItem(item);
        }
        return [item];
    }
    async function processItems(items) {
        return (await Promise.all(items.map(processItem))).flat();
    }
    const processedSidebar = await processItems(unprocessedSidebar);
    const fixSidebarItemInconsistencies = (item) => {
        // A non-collapsible category can't be collapsed!
        if (item.type === 'category' && !item.collapsible && item.collapsed) {
            return {
                ...item,
                collapsed: false,
            };
        }
        return item;
    };
    return (0, utils_1.transformSidebarItems)(processedSidebar, fixSidebarItemInconsistencies);
}
async function processSidebars(unprocessedSidebars, params) {
    return (0, combine_promises_1.default)((0, lodash_1.mapValues)(unprocessedSidebars, (unprocessedSidebar) => processSidebar(unprocessedSidebar, params)));
}
exports.processSidebars = processSidebars;
