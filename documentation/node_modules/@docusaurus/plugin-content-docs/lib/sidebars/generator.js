"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSidebarItemsGenerator = exports.CategoryMetadataFilenamePattern = exports.CategoryMetadataFilenameBase = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const utils_1 = require("@docusaurus/utils");
const logger_1 = (0, tslib_1.__importDefault)(require("@docusaurus/logger"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const fs_extra_1 = (0, tslib_1.__importDefault)(require("fs-extra"));
const js_yaml_1 = (0, tslib_1.__importDefault)(require("js-yaml"));
const validation_1 = require("./validation");
const docs_1 = require("../docs");
const BreadcrumbSeparator = '/';
// To avoid possible name clashes with a folder of the same name as the ID
const docIdPrefix = '$doc$/';
// Just an alias to the make code more explicit
function getLocalDocId(docId) {
    return (0, lodash_1.last)(docId.split('/'));
}
exports.CategoryMetadataFilenameBase = '_category_';
exports.CategoryMetadataFilenamePattern = '_category_.{json,yml,yaml}';
// TODO I now believe we should read all the category metadata files ahead of time: we may need this metadata to customize docs metadata
// Example use-case being able to disable number prefix parsing at the folder level, or customize the default route path segment for an intermediate directory...
// TODO later if there is `CategoryFolder/with-category-name-doc.md`, we may want to read the metadata as yaml on it
// see https://github.com/facebook/docusaurus/issues/3464#issuecomment-818670449
async function readCategoryMetadataFile(categoryDirPath) {
    async function tryReadFile(filePath) {
        const contentString = await fs_extra_1.default.readFile(filePath, { encoding: 'utf8' });
        const unsafeContent = js_yaml_1.default.load(contentString);
        try {
            return (0, validation_1.validateCategoryMetadataFile)(unsafeContent);
        }
        catch (e) {
            logger_1.default.error `The docs sidebar category metadata file path=${filePath} looks invalid!`;
            throw e;
        }
    }
    // eslint-disable-next-line no-restricted-syntax
    for (const ext of ['.json', '.yml', '.yaml']) {
        // Simpler to use only posix paths for mocking file metadata in tests
        const filePath = (0, utils_1.posixPath)(path_1.default.join(categoryDirPath, `${exports.CategoryMetadataFilenameBase}${ext}`));
        if (await fs_extra_1.default.pathExists(filePath)) {
            return tryReadFile(filePath);
        }
    }
    return null;
}
// Comment for this feature: https://github.com/facebook/docusaurus/issues/3464#issuecomment-818670449
const DefaultSidebarItemsGenerator = async ({ numberPrefixParser, docs: allDocs, options, item: { dirName: autogenDir }, version, }) => {
    const docsById = (0, docs_1.createDocsByIdIndex)(allDocs);
    const findDoc = (docId) => docsById[docId];
    const getDoc = (docId) => {
        const doc = findDoc(docId);
        if (!doc) {
            throw new Error(`Can't find any doc with id=${docId}.\nAvailable doc ids:\n- ${Object.keys(docsById).join('\n- ')}`);
        }
        return doc;
    };
    /**
     * Step 1. Extract the docs that are in the autogen dir.
     */
    function getAutogenDocs() {
        function isInAutogeneratedDir(doc) {
            return (
            // Doc at the root of the autogenerated sidebar dir
            doc.sourceDirName === autogenDir ||
                // autogen dir is . and doc is in subfolder
                autogenDir === '.' ||
                // autogen dir is not . and doc is in subfolder
                // "api/myDoc" startsWith "api/" (note "api2/myDoc" is not included)
                doc.sourceDirName.startsWith((0, utils_1.addTrailingSlash)(autogenDir)));
        }
        const docs = allDocs.filter(isInAutogeneratedDir);
        if (docs.length === 0) {
            logger_1.default.warn `No docs found in path=${autogenDir}: can't auto-generate a sidebar.`;
        }
        return docs;
    }
    /**
     * Step 2. Turn the linear file list into a tree structure.
     */
    function treeify(docs) {
        // Get the category breadcrumb of a doc (relative to the dir of the autogenerated sidebar item)
        // autogenDir=a/b and docDir=a/b/c/d => returns [c, d]
        // autogenDir=a/b and docDir=a/b => returns []
        // TODO: try to use path.relative()
        function getRelativeBreadcrumb(doc) {
            return autogenDir === doc.sourceDirName
                ? []
                : doc.sourceDirName
                    .replace((0, utils_1.addTrailingSlash)(autogenDir), '')
                    .split(BreadcrumbSeparator);
        }
        const treeRoot = {};
        docs.forEach((doc) => {
            const breadcrumb = getRelativeBreadcrumb(doc);
            let currentDir = treeRoot; // We walk down the file's path to generate the fs structure
            // eslint-disable-next-line no-restricted-syntax
            for (const dir of breadcrumb) {
                if (typeof currentDir[dir] === 'undefined') {
                    currentDir[dir] = {}; // Create new folder.
                }
                currentDir = currentDir[dir]; // Go into the subdirectory.
            }
            currentDir[`${docIdPrefix}${doc.id}`] = null; // We've walked through the file path. Register the file in this directory.
        });
        return treeRoot;
    }
    /**
     * Step 3. Recursively transform the tree-like file structure to sidebar items.
     * (From a record to an array of items, akin to normalizing shorthand)
     */
    function generateSidebar(fsModel) {
        function createDocItem(id) {
            const { sidebarPosition: position, frontMatter: { sidebar_label: label, sidebar_class_name: className }, } = getDoc(id);
            return {
                type: 'doc',
                id,
                position,
                // We don't want these fields to magically appear in the generated sidebar
                ...(label !== undefined && { label }),
                ...(className !== undefined && { className }),
            };
        }
        async function createCategoryItem(dir, fullPath, folderName) {
            var _a, _b, _c, _d;
            const categoryPath = path_1.default.join(version.contentPath, autogenDir, fullPath);
            const categoryMetadata = await readCategoryMetadataFile(categoryPath);
            const className = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.className;
            const { filename, numberPrefix } = numberPrefixParser(folderName);
            const allItems = await Promise.all(Object.entries(dir).map(([key, content]) => dirToItem(content, key, `${fullPath}/${key}`)));
            // Try to match a doc inside the category folder,
            // using the "local id" (myDoc) or "qualified id" (dirName/myDoc)
            function findDocByLocalId(localId) {
                return allItems.find((item) => item.type === 'doc' && getLocalDocId(item.id) === localId);
            }
            function findConventionalCategoryDocLink() {
                return allItems.find((item) => item.type === 'doc' && (0, docs_1.isConventionalDocIndex)(getDoc(item.id)));
            }
            function getCategoryLinkedDocId() {
                var _a, _b;
                const link = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.link;
                if (link) {
                    if (link.type === 'doc') {
                        return ((_a = findDocByLocalId(link.id)) === null || _a === void 0 ? void 0 : _a.id) || getDoc(link.id).id;
                    }
                    else {
                        // We don't continue for other link types on purpose!
                        // IE if user decide to use type "generated-index", we should not pick a README.md file as the linked doc
                        return undefined;
                    }
                }
                // Apply default convention to pick index.md, README.md or <categoryName>.md as the category doc
                return (_b = findConventionalCategoryDocLink()) === null || _b === void 0 ? void 0 : _b.id;
            }
            const categoryLinkedDocId = getCategoryLinkedDocId();
            const link = categoryLinkedDocId
                ? {
                    type: 'doc',
                    id: categoryLinkedDocId, // We "remap" a potentially "local id" to a "qualified id"
                }
                : // TODO typing issue
                    categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.link;
            // If a doc is linked, remove it from the category subItems
            const items = allItems.filter((item) => !(item.type === 'doc' && item.id === categoryLinkedDocId));
            return {
                type: 'category',
                label: (_a = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.label) !== null && _a !== void 0 ? _a : filename,
                collapsible: (_b = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.collapsible) !== null && _b !== void 0 ? _b : options.sidebarCollapsible,
                collapsed: (_c = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.collapsed) !== null && _c !== void 0 ? _c : options.sidebarCollapsed,
                position: (_d = categoryMetadata === null || categoryMetadata === void 0 ? void 0 : categoryMetadata.position) !== null && _d !== void 0 ? _d : numberPrefix,
                ...(className !== undefined && { className }),
                items,
                ...(link && { link }),
            };
        }
        async function dirToItem(dir, // The directory item to be transformed.
        itemKey, // For docs, it's the doc ID; for categories, it's used to generate the next `relativePath`.
        fullPath) {
            return dir
                ? createCategoryItem(dir, fullPath, itemKey)
                : createDocItem(itemKey.substring(docIdPrefix.length));
        }
        return Promise.all(Object.entries(fsModel).map(([key, content]) => dirToItem(content, key, key)));
    }
    /**
     * Step 4. Recursively sort the categories/docs + remove the "position" attribute from final output.
     * Note: the "position" is only used to sort "inside" a sidebar slice. It is not
     * used to sort across multiple consecutive sidebar slices (ie a whole Category
     * composed of multiple autogenerated items)
     */
    function sortItems(sidebarItems) {
        const processedSidebarItems = sidebarItems.map((item) => {
            if (item.type === 'category') {
                return { ...item, items: sortItems(item.items) };
            }
            return item;
        });
        const sortedSidebarItems = (0, lodash_1.sortBy)(processedSidebarItems, (item) => item.position);
        return sortedSidebarItems.map(({ position, ...item }) => item);
    }
    // TODO: the whole code is designed for pipeline operator
    // return getAutogenDocs() |> treeify |> await generateSidebar(^) |> sortItems;
    const docs = getAutogenDocs();
    const fsModel = treeify(docs);
    const sidebarWithPosition = await generateSidebar(fsModel);
    const sortedSidebar = sortItems(sidebarWithPosition);
    return sortedSidebar;
};
exports.DefaultSidebarItemsGenerator = DefaultSidebarItemsGenerator;
