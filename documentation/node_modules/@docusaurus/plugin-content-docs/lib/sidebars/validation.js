"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCategoryMetadataFile = exports.validateSidebars = void 0;
const utils_validation_1 = require("@docusaurus/utils-validation");
const utils_1 = require("./utils");
const sidebarItemBaseSchema = utils_validation_1.Joi.object({
    className: utils_validation_1.Joi.string(),
    customProps: utils_validation_1.Joi.object().unknown(),
});
const sidebarItemAutogeneratedSchema = sidebarItemBaseSchema.append({
    type: 'autogenerated',
    dirName: utils_validation_1.Joi.string()
        .required()
        .pattern(/^[^/](.*[^/])?$/)
        .message('"dirName" must be a dir path relative to the docs folder root, and should not start or end with slash'),
});
const sidebarItemDocSchema = sidebarItemBaseSchema.append({
    type: utils_validation_1.Joi.string().valid('doc', 'ref').required(),
    id: utils_validation_1.Joi.string().required(),
    label: utils_validation_1.Joi.string(),
});
const sidebarItemLinkSchema = sidebarItemBaseSchema.append({
    type: 'link',
    href: utils_validation_1.URISchema.required(),
    label: utils_validation_1.Joi.string()
        .required()
        .messages({ 'any.unknown': '"label" must be a string' }),
});
const sidebarItemCategoryLinkSchema = utils_validation_1.Joi.object()
    .when('.type', {
    switch: [
        {
            is: 'doc',
            then: utils_validation_1.Joi.object({
                type: 'doc',
                id: utils_validation_1.Joi.string().required(),
            }),
        },
        {
            is: 'generated-index',
            then: utils_validation_1.Joi.object({
                type: 'generated-index',
                slug: utils_validation_1.Joi.string().optional(),
                // permalink: Joi.string().optional(), // No, this one is not in the user config, only in the normalized version
                title: utils_validation_1.Joi.string().optional(),
                description: utils_validation_1.Joi.string().optional(),
            }),
        },
        {
            is: utils_validation_1.Joi.string().required(),
            then: utils_validation_1.Joi.forbidden().messages({
                'any.unknown': 'Unknown sidebar category link type "{.type}".',
            }),
        },
    ],
})
    .id('sidebarCategoryLinkSchema');
const sidebarItemCategorySchema = sidebarItemBaseSchema.append({
    type: 'category',
    label: utils_validation_1.Joi.string()
        .required()
        .messages({ 'any.unknown': '"label" must be a string' }),
    // TODO: Joi doesn't allow mutual recursion. See https://github.com/sideway/joi/issues/2611
    items: utils_validation_1.Joi.array()
        .required()
        .messages({ 'any.unknown': '"items" must be an array' }),
    link: sidebarItemCategoryLinkSchema,
    collapsed: utils_validation_1.Joi.boolean().messages({
        'any.unknown': '"collapsed" must be a boolean',
    }),
    collapsible: utils_validation_1.Joi.boolean().messages({
        'any.unknown': '"collapsible" must be a boolean',
    }),
});
const sidebarItemSchema = utils_validation_1.Joi.object()
    .when('.type', {
    switch: [
        { is: 'link', then: sidebarItemLinkSchema },
        {
            is: utils_validation_1.Joi.string().valid('doc', 'ref').required(),
            then: sidebarItemDocSchema,
        },
        { is: 'autogenerated', then: sidebarItemAutogeneratedSchema },
        { is: 'category', then: sidebarItemCategorySchema },
        {
            is: utils_validation_1.Joi.any().required(),
            then: utils_validation_1.Joi.forbidden().messages({
                'any.unknown': 'Unknown sidebar item type "{.type}".',
            }),
        },
    ],
})
    .id('sidebarItemSchema');
function validateSidebarItem(item) {
    if (typeof item === 'string') {
        return;
    }
    // TODO: remove once with proper Joi support
    // Because we can't use Joi to validate nested items (see above), we do it manually
    if ((0, utils_1.isCategoriesShorthand)(item)) {
        Object.values(item).forEach((category) => category.forEach(validateSidebarItem));
    }
    else {
        utils_validation_1.Joi.assert(item, sidebarItemSchema);
        if (item.type === 'category') {
            item.items.forEach(validateSidebarItem);
        }
    }
}
function validateSidebars(sidebars) {
    Object.values(sidebars).forEach((sidebar) => {
        if (Array.isArray(sidebar)) {
            sidebar.forEach(validateSidebarItem);
        }
        else {
            validateSidebarItem(sidebar);
        }
    });
}
exports.validateSidebars = validateSidebars;
const categoryMetadataFileSchema = utils_validation_1.Joi.object({
    label: utils_validation_1.Joi.string(),
    position: utils_validation_1.Joi.number(),
    collapsed: utils_validation_1.Joi.boolean(),
    collapsible: utils_validation_1.Joi.boolean(),
    className: utils_validation_1.Joi.string(),
    link: sidebarItemCategoryLinkSchema,
});
function validateCategoryMetadataFile(unsafeContent) {
    return utils_validation_1.Joi.attempt(unsafeContent, categoryMetadataFileSchema);
}
exports.validateCategoryMetadataFile = validateCategoryMetadataFile;
