{"version":3,"file":"style-to-object.min.js","sources":["../node_modules/inline-style-parser/index.js","../index.js"],"sourcesContent":["// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","var parse = require('inline-style-parser');\n\n/**\n * Parses inline style to object.\n *\n * @example\n * // returns { 'line-height': '42' }\n * StyleToObject('line-height: 42;');\n *\n * @param  {String}      style      - The inline style.\n * @param  {Function}    [iterator] - The iterator function.\n * @return {null|Object}\n */\nfunction StyleToObject(style, iterator) {\n  var output = null;\n  if (!style || typeof style !== 'string') {\n    return output;\n  }\n\n  var declaration;\n  var declarations = parse(style);\n  var hasIterator = typeof iterator === 'function';\n  var property;\n  var value;\n\n  for (var i = 0, len = declarations.length; i < len; i++) {\n    declaration = declarations[i];\n    property = declaration.property;\n    value = declaration.value;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      output || (output = {});\n      output[property] = value;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = StyleToObject;\n"],"names":["style","options","TypeError","lineno","column","updatePosition","str","lines","match","NEWLINE_REGEX","length","i","lastIndexOf","position","start","line","node","Position","whitespace","this","end","source","error","msg","err","Error","reason","filename","silent","re","m","exec","slice","WHITESPACE_REGEX","comments","rules","c","comment","push","pos","charAt","EMPTY_STRING","type","declaration","prop","PROPERTY_REGEX","COLON_REGEX","val","VALUE_REGEX","ret","property","trim","replace","COMMENT_REGEX","value","SEMICOLON_REGEX","prototype","content","decl","decls","declarations","TRIM_REGEX","iterator","output","parse","hasIterator","len"],"mappings":"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"}